package org.xworkz.prodex.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;
import org.xworkz.prodex.dto.EnrollmentDto;
import org.xworkz.prodex.dto.LoginDto;
import org.xworkz.prodex.service.ProdexService;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Controller
@RequestMapping("/")
public class ProdexController {

    @Autowired
    private ProdexService prodexService;

    private static final long OTP_VALIDITY_MS = 2 * 60 * 1000L;

    // --- 1. loginPage Method ---
    @GetMapping("loginPage")
    public String loginPage(
            @RequestParam(value = "error", required = false) String error,
            @RequestParam(value = "errorField", required = false) String errorField,
            @RequestParam(value = "emailOrContact", required = false) String emailOrContact,
            @RequestParam(value = "success", required = false) String success,
            Model model) {

        if (error != null && emailOrContact != null && !emailOrContact.trim().isEmpty()) {
            model.addAttribute("emailPrefill", emailOrContact.trim());
        }

        model.addAttribute("errorMessage", error != null ? error.replace("+", " ") : "");
        model.addAttribute("errorField", errorField != null ? errorField : "");
        model.addAttribute("successMessage", success != null ? success.replace("+", " ") : "");

        return "login";
    }

    // --- 2. loginUser Method ---
    @PostMapping("loginUser")
    public String loginUser(@RequestParam("emailOrContact") String emailOrContact,
                            @RequestParam("password") String password) {

        if (emailOrContact == null || emailOrContact.trim().isEmpty() || password == null || password.trim().isEmpty()) {
            return "redirect:/loginPage?error=Please+enter+both+email/contact+and+password&emailOrContact=" + emailOrContact;
        }

        try {
            EnrollmentDto enrollment = prodexService.findEnrollmentEntityByEmailOrContact(emailOrContact.trim());
            if (enrollment == null) {
                return "redirect:/loginPage?error=User+not+found&errorField=emailOrContact&emailOrContact=" + emailOrContact;
            }

            if (enrollment.isAccountLocked()) {
                return "redirect:/loginPage?error=Account+locked.+Please+reset+your+password+to+unlock&errorField=password&emailOrContact=" + emailOrContact;
            }

            boolean passwordValid = prodexService.checkPassword(new LoginDto(emailOrContact, enrollment.getPassword()), password);

            if (!passwordValid) {
                int newAttemptCount = enrollment.getFailedAttempts() + 1;
                prodexService.updateFailedAttempts(emailOrContact.trim(), newAttemptCount);

                if (newAttemptCount >= 3) {
                    prodexService.lockAccount(emailOrContact.trim());
                    return "redirect:/loginPage?error=Account+locked+due+to+3+failed+attempts&errorField=password&emailOrContact=" + emailOrContact;
                }

                int remainingAttempts = 3 - newAttemptCount;
                return "redirect:/loginPage?error=Invalid+password.+" + remainingAttempts + "+attempts+remaining&errorField=password&emailOrContact=" + emailOrContact;
            }

            prodexService.resetFailedAttempts(emailOrContact.trim());
            String status = prodexService.loginAndStoreByRole(emailOrContact.trim(), password);

            if ("ADMIN_DASHBOARD".equals(status)) {
                return "redirect:/administrator/administratorDashboardPage?email=" + emailOrContact.trim();
            } else {
                return "redirect:/member/memberDashboardPage?email=" + emailOrContact.trim();
            }

        } catch (Exception e) {
            return "redirect:/loginPage?error=Internal+server+error&emailOrContact=" + emailOrContact;
        }
    }

    // --- 3. checkUserExist Method (AJAX) ---
    @GetMapping("/checkUserExist")
    @ResponseBody
    public Map<String, String> checkUserExist(@RequestParam("emailOrContact") String emailOrContact) {
        Map<String, String> response = new HashMap<>();
        try {
            EnrollmentDto dto = prodexService.findEnrollmentEntityByEmailOrContact(emailOrContact.trim());
            if (dto != null) {
                response.put("status", dto.isAccountLocked() ? "ACCOUNT_LOCKED" : "FOUND");
            } else {
                response.put("status", "NOT_FOUND");
            }
        } catch (Exception e) {
            response.put("status", "ERROR");
        }
        return response;
    }

    // --- 4. checkPassword Method (AJAX) ---
    @PostMapping("/checkPassword")
    @ResponseBody
    public Map<String, String> checkPassword(@RequestParam String emailOrContact, @RequestParam String password) {
        Map<String, String> response = new HashMap<>();
        try {
            EnrollmentDto enrollment = prodexService.findEnrollmentEntityByEmailOrContact(emailOrContact.trim());
            if (enrollment == null) {
                response.put("status", "USER_NOT_FOUND");
                return response;
            }
            if (enrollment.isAccountLocked()) {
                response.put("status", "ACCOUNT_LOCKED");
                return response;
            }
            if (!prodexService.checkPassword(new LoginDto(emailOrContact, enrollment.getPassword()), password)) {
                int count = enrollment.getFailedAttempts() + 1;
                prodexService.updateFailedAttempts(emailOrContact.trim(), count);
                if (count >= 3) {
                    prodexService.lockAccount(emailOrContact.trim());
                    response.put("status", "ACCOUNT_LOCKED");
                } else {
                    response.put("status", "INVALID_PASSWORD");
                    response.put("remainingAttempts", String.valueOf(3 - count));
                }
                return response;
            }
            prodexService.resetFailedAttempts(emailOrContact.trim());
            response.put("status", "SUCCESS");
        } catch (Exception e) {
            response.put("status", "ERROR");
        }
        return response;
    }

    // --- 5. forgotPasswordPage Method ---
    @GetMapping("forgotPasswordPage")
    public String forgotPasswordPage(@RequestParam(value = "error", required = false) String error,
                                     @RequestParam(value = "errorField", required = false) String errorField,
                                     @RequestParam(value = "email", required = false) String email, Model model) {
        model.addAttribute("emailPrefill", email != null ? email : "");
        model.addAttribute("errorMessage", error != null ? error.replace("+", " ") : "");
        model.addAttribute("errorField", errorField != null ? errorField : "");
        return "forgotPassword";
    }

    // --- 6. sendOtp Method ---
    @PostMapping("sendOtp")
    public String sendOtp(@RequestParam("email") String email) {
        try {
            EnrollmentDto enrollment = prodexService.findEnrollmentByEmail(email.trim());
            if (enrollment == null) {
                return "redirect:/forgotPasswordPage?error=Email+not+found&errorField=email&email=" + email;
            }
            boolean emailSent = prodexService.sendOtpToEmail(email.trim());
            return emailSent ? "redirect:/verifyOtpPage?email=" + email.trim() : "redirect:/forgotPasswordPage?error=Failed+to+send+OTP&email=" + email;
        } catch (Exception e) {
            return "redirect:/forgotPasswordPage?error=Internal+error&email=" + email;
        }
    }

    // --- 7. checkRegisteredEmail Method (AJAX) ---
    @GetMapping("/checkRegisteredEmail")
    @ResponseBody
    public Map<String, String> checkRegisteredEmail(@RequestParam("email") String email) {
        Map<String, String> response = new HashMap<>();
        try {
            EnrollmentDto enrollment = prodexService.findEnrollmentByEmail(email.trim());
            response.put("status", enrollment != null ? "FOUND" : "NOT_FOUND");
        } catch (Exception e) {
            response.put("status", "ERROR");
        }
        return response;
    }

    // --- 8. sendInitialOtp Method ---
    @PostMapping("/sendInitialOtp")
    public String sendInitialOtp(@RequestParam String email) {
        return sendOtp(email); // Reuses logic for cleaner code
    }

    // --- 9. showVerifyOtpPage Method ---
    @GetMapping("verifyOtpPage")
    public String showVerifyOtpPage(@RequestParam(value = "error", required = false) String error,
                                    @RequestParam(value = "errorField", required = false) String errorField,
                                    @RequestParam(value = "email", required = false) String email,
                                    Model model) {
        if (email == null || email.trim().isEmpty()) return "redirect:/forgotPasswordPage";
        try {
            EnrollmentDto enrollment = prodexService.findEnrollmentByEmail(email.trim());
            if (enrollment == null) return "redirect:/forgotPasswordPage";

            model.addAttribute("emailPrefill", email);
            model.addAttribute("errorMessage", error != null ? error.replace("+", " ") : "");
            model.addAttribute("errorField", errorField != null ? errorField : "");

            if (enrollment.getOtpCreatedAt() != null) {
                long remaining = Duration.between(LocalDateTime.now(), enrollment.getOtpCreatedAt().plusMinutes(2)).toMillis();
                model.addAttribute("remainingTime", Math.max(0, remaining));
            }
            return "verifyOtp";
        } catch (Exception e) {
            return "redirect:/forgotPasswordPage";
        }
    }

    // --- 10. verifyOtp Method ---
    @PostMapping("verifyOtp")
    public String verifyOtp(@RequestParam String email, @RequestParam String otp) {
        try {
            boolean verified = prodexService.verifyOtp(email.trim(), otp.trim());
            return verified ? "redirect:/resetPasswordPage?email=" + email.trim() : "redirect:/verifyOtpPage?email=" + email.trim() + "&error=Invalid+or+expired+OTP&errorField=otp";
        } catch (Exception e) {
            return "redirect:/verifyOtpPage?email=" + email.trim() + "&error=Server+error";
        }
    }

    // --- 11. resendOtp Method ---
    @PostMapping("resendOtp")
    public String resendOtp(@RequestParam String email) {
        return sendOtp(email);
    }

    // --- 12. resetPasswordPage Method ---
    @GetMapping("resetPasswordPage")
    public String resetPasswordPage(@RequestParam String email,
                                    @RequestParam(value = "error", required = false) String error,
                                    @RequestParam(value = "errorField", required = false) String errorField, Model model) {
        model.addAttribute("emailPrefill", email);
        model.addAttribute("errorMessage", error != null ? error.replace("+", " ") : "");
        model.addAttribute("errorField", errorField != null ? errorField : "");
        return "resetPassword";
    }

    // --- 13. updatePassword Method ---
    @PostMapping("updatePassword")
    public String updatePassword(@RequestParam String email, @RequestParam String password, @RequestParam String confirmPassword) {
        if (!password.equals(confirmPassword)) {
            return "redirect:/resetPasswordPage?email=" + email + "&error=Passwords+do+not+match&errorField=confirmPassword";
        }
        try {
            List<String> errors = new ArrayList<>();
            // Crucial: Use the updatePasswordAndUnlock method to fix account state
            boolean updated = prodexService.updatePasswordAndUnlock(email.trim(), password, errors);
            if (updated) {
                return "redirect:/loginPage?emailOrContact=" + email + "&success=Password+reset+successful.+Account+unlocked.";
            } else {
                return "redirect:/resetPasswordPage?email=" + email + "&error=Update+failed&errorField=password";
            }
        } catch (Exception e) {
            return "redirect:/resetPasswordPage?email=" + email + "&error=Server+error";
        }
    }
}